#!/usr/bin/env python
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""Deletes files from a Cloud Files container en-masse."""

import pyrax
import argparse

from Queue import Queue
from collections import deque

from Queue import Empty as EmptyQueue
from swiftclient import client as _swift_client


class RingBuffer(deque):

    """Inherits deque, pops old data to maintain size.

    append() is a normal append, but it also checks the length of the deque
    and will swap append() to full_append() when the size is reached.
    full_append() is appends new data and then pops old data.

    """

    def __init__(self, size, max_value=None):
        deque.__init__(self)
        self.size = size
        self.max_value = max_value

    def append(self, item):
        """Append a new item and pop an old one if necessary.

        New item is appended onto the right (end) of the deque and then pops an
        item off the beginning (left) of the deque in order to maintain it's
        a length equal to self.size.  It will also log a warning if the value
        is greater than 75% of self.max_value, and will not append values
        greater than self.max_value.

        """
        if self.max_value is not None:
            #if self.max_value > item > (self.max_value * .75):
            if self.max_value > item > 10:
                LOG.debug("Stalled thread just finished with an API time of "
                          "%s", round(item, 2))
            if item > self.max_value:
                LOG.warning("Stalled thread just finished with an API time of"
                            "%s ,not recording this outlier", round(item, 2))
            else:
                deque.append(self, item)
                if len(self) > self.size:
                    # full, pop the oldest item, left most item
                    self.popleft()
        else:
            deque.append(self, item)
            if len(self) > self.size:
                # full, pop the oldest item, left most item
                self.popleft()

    def get(self):
        """Return a list of size items (newest items)."""
        return list(self)


class StoppableThread(pyrax.utils.threading.Thread):

    """Thread class with a stop() method.

    The thread itself has to check regularly for the stopped() condition.

    """

    def __init__(self):
        super(StoppableThread, self).__init__()
        self._stop = pyrax.utils.threading.Event()
        self._pause = pyrax.utils.threading.Event()

    def stop(self):
        """Set the _stop threading event."""
        self._stop.set()

    def stopped(self):
        """Return True if the thread should stop.

        It is up to the descendent thread class to actually do the stopping

        """
        return self._stop.isSet()

    def paused(self):
        """Return True if the thread should pause.

        It is up to the descendent thread class to actually do the waiting.

        """
        return self._pause.isSet()

    def pause(self):
        """Set the _pause threading event."""
        self._pause.set()

    def unpause(self):
        """Clear the _pause threading event."""
        self._pause.clear()


class ThreadManager(StoppableThread):

    """Maintain a thread pool for performing deletes.

    The ThreadManager has a settable thread_target and it will either create or
    stop threads as appropriate to make sure that the number of threads is
    equal to the thread_target.

    Threads are only created or stopped once every tenth of a second.

    """

    def __init__(self, maxthreads=350):
        super(ThreadManager, self).__init__()
        self._stop = pyrax.utils.threading.Event()
        self.thread_target = 30
        self.threads_max = maxthreads
        self.threads = []
        self._pause = pyrax.utils.threading.Event()
        self._make_threads()

    @property
    def active(self):
        """Return a list of all unpaused threads.

        This is a method (decorated with @property) which returns a list of
        threads from self.threads which are paused.

        """
        return [thread for thread in self.threads if not thread.paused()]

    @property
    def idle(self):
        """Return a list of all unpaused threads.

        This is a method (decorated with @property) which returns a list of
        threads from self.threads which are paused.

        """
        return [thread for thread in self.threads if thread.paused() and not thread.busy]

    @property
    def busy(self):
        """Return a list of all unpaused threads.

        This is a method (decorated with @property) which returns a list of
        threads from self.threads which are paused.

        """
        return [thread for thread in self.threads if thread.busy]

    @property
    def _paused(self):
        """Return a list of all unpaused threads.

        This is a method (decorated with @property) which returns a list of
        threads from self.threads which are paused.

        """
        return [thread for thread in self.threads if thread.paused()]

    def _make_threads(self):
        """Create all of the worker threads.

        This will create worker threads until the number of threads is equal to
        self.threads_max.

        """
        while len(self.threads) < self.threads_max:
            if len(self.threads) % 10 == 0:
                LOG.debug("%s/%s threads created",
                          len(self.threads), self.threads_max)
            self.threads.append(self._spawn_thread())

    @classmethod
    def _spawn_thread(cls):
        """Spawn a worker thread.

        Quick internal function to streamline later code.  Create a thread
        object, set it to be a daemon thread and start it up.  Return the
        created thread object.  All threads are created in a "paused" state.

        """
        LOG.debug("Spawning a worker thread")
        thread = WorkerThread()
        thread.daemon = True
        thread.pause()
        thread.start()
        return thread

    def show_status(self):
        """Check for any threads that have died, and replace them.

        Iterate across the lists of idle and active threads, check
        thread.isActive on each, remove them from the list if they are dead,
        report findings to DEBUG and regenerate and threads that had died.

        """
        dead = len([thread for thread in self.threads if not thread.isAlive()])
        alive = len([thread for thread in self.threads if thread.isAlive()])
        LOG.info("Threads; Dead: %s\tAlive: %s\tPaused: %s\tActive: "
                 "%s\tBusy: %s\tIdle: %s", dead, alive, len(self._paused),
                 len(self.active), len(self.busy), len(self.idle))

    def set_thread_target(self, target):
        """Alter the target number of worker threads.

        Only allows changes to the number of worker threads if it has already
        achieved the last target, and if there is actually work in the queue to
        be performed.

        """
        if ((len(self.busy) >= self.thread_target or
                target < self.thread_target) and
                not CFK.queue.empty()):
            if target < self.threads_max:
                self.thread_target = target
            else:
                self.thread_target = self.threads_max

    def run(self):
        """The main loop.

        This method will run an infinite loop which will create or stop worker
        threads as appropriate in order to achieve the target number of
        threads.  The target number of threads is set with the
        set_thread_target method.

        """
        while not self.stopped():
            while not self.paused():
                pyrax.utils.time.sleep(.1)
                if len(self.active) < self.thread_target:
                    self._unpause()
                while len(self.active) > self.thread_target and len(self.active) > 0:
                    thread = self.active[0]
                    LOG.debug("Pausing thread %s", thread.name)
                    thread.pause()
            pyrax.utils.time.sleep(1)

    def stop(self):
        """Command all threads to stop.

        First sets it's own stop event to stop the main run loop and then
        iterate across all of the worker threads and command them to stop as
        well.

        """
        super(ThreadManager, self).stop()
        LOG.warning("Shutdown requested, stopping all threads!")
        for thread in self.threads:
            thread.stop()
        for thread in self.threads:
            if thread.isAlive():
                thread.stop()
                pyrax.utils.time.sleep(.25)
        LOG.warning("Thread shutdown complete, time for night night")

    def _pause_all_threads(self):
        """Iterate across the worker threads and command them to pause."""
        for thread in self.threads:
            LOG.debug("Pausing thread %s", thread.name)
            thread.pause()

    def _unpause(self):
        """Iterate across the worker threads and command them to resume."""
        while len(self.active) < self.thread_target and not self.paused() and len(self.idle) > 0:
            thread = self._paused[0]
            LOG.debug("Unpausing thread %s", thread.name)
            thread.unpause()
            pyrax.utils.time.sleep(.05)

    def pausethreads(self):
        """Pause all worker threads for duration."""
        self._pause_all_threads()
        self.pause()
        pyrax.utils.time.sleep(10)
        self.unpause()


class WorkerThread(StoppableThread):

    """Thread which actually performs a delete from Cloud Files.

    The WorkerThread will perform a delete against a Cloud Files object, record
    the time that it took to perform the delete API call, report that to the
    main class via the speed RingBuffer, and increment the deleted object count
    by one.

    """

    def __init__(self):
        super(WorkerThread, self).__init__()
        self._stop = pyrax.utils.threading.Event()
        self._pause = pyrax.utils.threading.Event()
        self.busy = False

    def run(self):
        """The main loop for the worker thread.

        The processing loop order is:

            - Check if stoped, if so, break out of the loop
            - Check if paused, if so, sleep for one second and recheck
            - Poll the object queue
            - Delete the object
            - Record the time the API operation took in the speeds RingBuffer
            - Increment the deleted object count

        """
        while not self.stopped():
            self.busy = False
            while self.paused() and not self.stopped():
                pyrax.utils.time.sleep(1)
            try:
                obj = CFK.queue.get(timeout=1)
            except EmptyQueue:
                pass
            else:
                self.busy = True
                try:
                    start = pyrax.utils.time.time()
                    obj.delete()
                    CFK.speeds.append(pyrax.utils.time.time() - start)
                    if ARGS.api_times:
                        LOG.info("API operation time: %s",
                                 pyrax.utils.time.time() - start)
                except _swift_client.ClientException as exc:
                    if not self.stopped():
                        LOG.warning("Deleting object %s generated a "
                                    "swiftclient error; Status: %s; "
                                    "Message: %s", obj.name, exc.http_status,
                                    exc.message)
                except pyrax.exc.AuthorizationFailure as exc:
                    pyrax.identity.authenticated = False
                    CFK.queue.put(obj)
                    while pyrax.identity.authenticated is False:
                        pyrax.utils.time.sleep(1)
                CFK.queue.task_done()
                CFK.delete_complete()


class CFKraken():

    """The main class which controls everything else.

    This class will start up the ThreadManager, maintain the queue of objects
    to delete, and receive API call timings from the WorkerThreads.  The timing
    information is used to determine the "health" of the API backend.  If the
    API times are low, the backend is deemed healthy, and the targeted deletion
    rate is increased.  If the API times are high, then the reverse happens.

    """

    def __init__(self, **kwargs):
        self.deleted = 0
        self.target_rate = kwargs['target_rate']
        self._min_target = 10
        self._max_target = 90
        self.speeds = RingBuffer(25, max_value=60)
        self.speeds.append(0)
        LOG.info("Username : %s", kwargs['username'])
        LOG.info("API Key  : %s", kwargs['apikey'])
        LOG.info("Container: %s", kwargs['contname'])
        LOG.info("Region   : %s", kwargs['region'])
        LOG.info("SNet     : %s", kwargs['service_net'])
        pyrax.USER_AGENT = "CFKraken " + pyrax.USER_AGENT
        pyrax.set_setting('identity_type', 'rackspace')
        pyrax.set_default_region(kwargs['region'])
        pyrax.set_credentials(kwargs['username'], kwargs['apikey'],
                              region=kwargs['region'])
        # Invert the kwarg 'service_net' because we store if they want to use
        # service_net, whereas pyrax asks if you would like to use public_net.
        cfiles = pyrax.connect_to_cloudfiles(public=not kwargs['service_net'])
        self.cont = cfiles.get_container(kwargs['contname'])
        self.queue = Queue()
        self._finished = False
        self.tman = ThreadManager(kwargs['threads_max'])
        self.tman.daemon = True
        self.tman.name = "ThreadManager"
        self._last_object = ""

    def delete_complete(self):
        """Increment the count of deleted items by one."""
        self.deleted = self.deleted + 1

    def _populate_queue(self):
        """Pull down a new list of items from Cloud Files for deletion.

        To improve startup time, the first pull is only 2,000 items, all
        subsequest pulls will be the pyrax default of 10,000 items.

        Once the items are queried from Cloud Files, the list is then iterated
        over and the objects are put into the queue for deletion.

        """
        LOG.info("Populating queue")
        for attempt in range(5):
            try:
                if self.deleted > 0:
                    objs = (self.cont.get_objects(
                            marker=self._last_object))
                else:
                    objs = self.cont.get_objects(limit=2000)
            except _swift_client.ClientException as exc:
                LOG.warning("Populating queue failed (Attempt: %s; Status: %s;"
                            " Message: %s)", attempt, exc.http_status,
                            exc.message)
            except pyrax.exc.AuthorizationFailure as exc:
                pyrax.identity.authenticated = False
                LOG.warning("Auth expired, re-authenticating...")
                pyrax.authenticate()
                continue
            else:
                break
        else:
            LOG.error("Populating queue failed... giving up")
            exit()
        if len(objs) == 0:
            LOG.info("No more objects to pull from Cloud Files")
            self._finished = True
        for obj in objs:
            self.queue.put(obj)
            self._last_object = obj.name
        LOG.info("Queue size is %s", self.queue.qsize())

    def _alter_target_rate(self, adjustment=0):
        """ Alter the target object deletion rate.

        Set a new target object deletion rate while staying within the bounds
        of _min_target and _max_target.

        """
        self.target_rate = self.target_rate + adjustment
        if self.target_rate > self._max_target:
            self.target_rate = self._max_target
        if self.target_rate < self._min_target:
            self.target_rate = self._min_target

    def _safe_start(self):
        """Ensure that CFKraken is started safely."""

        kraken = r"""               _..--~~--.._
           .-~`            `~-.
          / .------.  .------. \
         / (       ()(       () \
         \  '------'  '------'  /
          )                    (
         /  .-.  .-.  .-.  .-.  \
        (  (  /  /  )  ) \  \ )  )
         \  \/  / \/  /  /\  /  /
          \  \ /\ (  (  /  )/  /
           )  )  ) )  )(  /(  (
          /  /( / /  /  \/  \  \
         /  /  \ /  / ) /  / \  \
        (  ( \  \  / / (  ( \ )  )
         \  \ \  \/ /  /)  ) /  /
          \__) \  \(  (/  / (__/
            /  /)  )\ (  ( \  \
           (  ((__// \ \  \ )  )
            \__)  /  /\ \__)  /
                 (  (  )  )  (
                  \__)/  / \__)
                     (__/"""
        print kraken
        LOG.info("Releasing the KRAKEN in 5 seconds... Ctrl-C to cancel")
        pyrax.utils.time.sleep(5)
        self._populate_queue()
        self.tman.start()

    def loop(self):
        """ The main loop, this should be triggered with the start() method.

        The main loop triggers pulling more items from Cloud Files when the
        queue runs low, as well as performs some analysis on the runtimes of
        API calls in order to estimate a "health" of the API and will
        increase or decrease the targeted rate of deletion accordingly.

        """
        self._safe_start()
        amount = 0
        rates = RingBuffer(5)
        rates.append(0)
        speed_avg = RingBuffer(5)
        bump_count = 1
        skip_rate = 0
        while (self.queue.unfinished_tasks > 0 or not self._finished):
            if (self.queue.qsize() < 500 and
                    (self.deleted + self.queue.qsize()) <
                    self.cont.object_count and
                    not self._finished):
                self._populate_queue()
                skip_rate = 1
            pyrax.utils.time.sleep(1)
            if not pyrax.identity.authenticated:
                pyrax.authenticate()
            rate = (self.deleted - amount) / 1
            # Stash the current amount so that we can calculate the difference
            # on the next pass
            amount = self.deleted
            if not skip_rate:
                rates.append(rate)
            skip_rate = 0
            ratel = rates.get()
            average_rate = (reduce(lambda x, y: x + y, ratel) / len(ratel))
            speedl = self.speeds.get()
            average_api = (reduce(lambda x, y: x + y, speedl) / len(speedl))
            speed_avg.append(average_api)
            api_health = reduce(lambda x, y: x + y, speed_avg) / len(speed_avg)
            new_target = (self.tman.thread_target +
                         (self.target_rate - average_rate))
            if new_target < self._min_target:
                new_target = self._min_target
            try:
                eta = str(pyrax.utils.datetime.timedelta(
                          seconds=(self.cont.object_count - self.deleted)
                          / self.target_rate))
            except ZeroDivisionError:
                eta = 'INF.'
            if ((api_health > 4 or
                    (average_rate < 5 and len(rates) == 5)) and
                    bump_count == 5):
                LOG.warning("API lag detected, pausing threads for 10 seconds "
                            "and lowering target rate")
                self._alter_target_rate(-5)
                new_target = self.target_rate
                self.tman.pausethreads()
                self.tman.set_thread_target(new_target)
                skip_rate = 1
            elif (api_health > 3 and bump_count == 5 and
                    self.target_rate > self._min_target and
                    self.tman.thread_target > self._min_target):
                LOG.info("API slowing down, dropping target rate")
                self._alter_target_rate(-2)
            elif (api_health < 2.5 and bump_count == 5 and
                    self.target_rate < self._max_target and
                    self.tman.thread_target < self.tman.threads_max and
                    (average_rate > 5 and len(rates) == 5)):
                LOG.info("API looks healthy, bumping target rate")
                self._alter_target_rate(1)
            if average_rate > (self.target_rate * .1):
                self.tman.set_thread_target(new_target)
            LOG.info("Deleted %s/%s objects (%s objects/second; obj/s target: "
                     "%s; threads: %s; thread target: %s; Average API call "
                     "time: %ss; API Health: %s) ETA: %s", self.deleted,
                     self.cont.object_count, average_rate, self.target_rate,
                     len(self.tman.active), self.tman.thread_target,
                     round(average_api, 2), round(api_health, 2), eta)
            self.tman.show_status()
            bump_count = bump_count + 1
            if bump_count > 5:
                bump_count = 1
        self.tman.stop()


if __name__ == '__main__':
    PARSER = argparse.ArgumentParser(description="Delete all objects from a "
                                     "targeted Cloud Files container using "
                                     "multithreading to increase deletion "
                                     "rates.  Also monitors the API system for"
                                     "response times and increases/reduces "
                                     "deletion rates as appropriate.",
                                     epilog="Written by Chris Jowett, "
                                     "chris.jowett@rackspace.com")
    PARSER.add_argument("username", help="Username of the account", type=str)
    PARSER.add_argument("apikey", help="Account API Key", type=str)
    PARSER.add_argument("container", help="name of the container to delete",
                        type=str)
    PARSER.add_argument("region", help="The region the container is in",
                        type=str, choices=['ORD', 'DFW', 'LON', 'SYD', 'IAD',
                                           'HKG'])
    PARSER.add_argument("-r", "--target-rate", help="The target rate to start "
                        "the deleting process at.  This will be adjusted based"
                        "on the API's health assessment. (default: "
                        "%(default)s)", type=int, nargs='?', default=30)
    PARSER.add_argument("-m", "--max-threads", help="The maximum number of "
                        "threads to have active.  A larger number here will "
                        "increase the maximum potential delete rate, but it "
                        "will also increase startup time. (default: "
                        "%(default)s)", type=int, nargs='?', default=350)
    PARSER.add_argument("-s", "--service-net", help="Use a Service Net "
                        "connection.  This script will have to be run from a "
                        "Cloud Server in the same region as the container you "
                        "are deleting for this to work... but it is HIGHLY "
                        "recommended (default: %(default)s)",
                        action="store_true")
    PARSER.add_argument("-t", "--api-times", help="Show the time taken for "
                        "each API call", action="store_true")
    PARSER.add_argument("-l", "--log-level", help=argparse.SUPPRESS, type=str,
                        default="INFO")
    ARGS = PARSER.parse_args()
    LOGLEVELS = {'INFO': pyrax.client.logging.INFO,
                 'WARNING': pyrax.client.logging.WARNING,
                 'DEBUG': pyrax.client.logging.DEBUG}
    LOG = pyrax.client.logging.getLogger("CFKraken")
    LOG.setLevel(LOGLEVELS[ARGS.log_level])
    LOG.addHandler(pyrax.client.logging.StreamHandler())
    CFK = CFKraken(username=ARGS.username,
                   apikey=ARGS.apikey,
                   contname=ARGS.container,
                   region=ARGS.region,
                   target_rate=ARGS.target_rate,
                   service_net=ARGS.service_net,
                   threads_max=ARGS.max_threads)
    try:
        CFK.loop()
    except (KeyboardInterrupt, SystemExit):
        CFK.queue.queue.clear()
        CFK.tman.stop()

